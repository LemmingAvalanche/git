* Troubleshooting segv still
[2024-02-07 on.]

This also fails:

#+begin_src
./git-format-patch --no-cover-letter --header-cmd=./test-cmd 'HEAD^{/★meta: base}'..@
#+end_src

=--no-cover-letter=

I was wondering if the cover letter was the culprit…? Anyway. It looks
like I get to process all my patches. Because it prints the patch name
of the last commit (currently) before dying:

#+begin_src
0038-NOTE-Smooth.patch
#+end_src

So does it die when cleaning up?

* Testing on my own email (21:39)
[2024-02-07 on.]

Sent it to my own email and the command-headers survive transit.

* Uuuh... extra headers are not generated for the cover letter?

Try for yourself:

#+begin_src
./git-format-patch --output-directory=patches --add-header='X-Complete-Garbage: ææææææææææææææ' --header-cmd=./test-cmd 'HEAD^{/★meta: base}'..@
#+end_src

This is the cover letter:

#+begin_src
From 9a8350fbc2e2ccbe63521a0faebab26bd8779738 Mon Sep 17 00:00:00 2001
Message-ID: <cover.1707418202.git.code@khaugsbakk.name>
From: Kristoffer Haugsbakk <code@khaugsbakk.name>
Date: Thu, 8 Feb 2024 19:50:02 +0100
Subject: [PATCH 00/40] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***
[…]
#+end_src

** Update: gulp, this must be a bug on my branch

Because I can’t reproduce it on master.

** TODO Fix =--add-header= for cover letter regression

...

I’m pretty sure it’s my move of

#+begin_src
rev.extra_headers = to_free = strbuf_detach(&buf, NULL);
#+end_src

But for fucks sake! The code is so fucking obtuse. Now I have to
restructure everything? God /fucking/ damnit.

** But there might be another way…

I have a /string buffer/. Right? I could, for each patch

- Push the extra headers on the buffer
- Pop after

The problem though is that the stupid =rev.extra_headers= is just a dumb
fucking char pointer. Ugh.

* TODO on commit “Never say die” ca.: CI fails because of leak

https://github.com/LemmingAvalanche/git/actions/runs/7905330519/job/21577718875

#+begin_src
Direct leak of 24 byte(s) in 1 object(s) allocated from:
    #0 0x7f52806124a3 in __interceptor_realloc ../../../../src/libsanitizer/lsan/lsan_interceptors.cpp:98
    #1 0x55c2158756b5 in xrealloc wrapper.c:137
    #2 0x55c215829412 in strbuf_grow strbuf.c:101
    #3 0x55c21573197e in all_headers log-tree.c:475
    #4 0x55c215731a2d in log_write_email_headers log-tree.c:490
    #5 0x55c21573297c in show_log log-tree.c:755
    #6 0x55c21573403c in log_tree_commit log-tree.c:1176
    #7 0x55c2155bf7db in cmd_log_walk_no_free builtin/log.c:522
    #8 0x55c2155c08b8 in cmd_show builtin/log.c:821
    #9 0x55c215542b42 in run_builtin git.c:469
    #10 0x55c215542fca in handle_builtin git.c:724
    #11 0x55c215543271 in run_argv git.c:788
    #12 0x55c21554385c in cmd_main git.c:923
    #13 0x55c21565827f in main common-main.c:62
    #14 0x7f5280229d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #15 0x7f5280229e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #16 0x55c215540cc4 in _start (git+0x1fcc4) (BuildId: 8c1bff2742603d7b82440c84a644906d8bf3435c)

DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--show_log--log_tree_commit--cmd_log_walk_no_free--cmd_show--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).
As TEST_PASSES_SANITIZE_LEAK=true and our logs show we're leaking, exit non-zero!
# faking up non-zero exit with --invert-exit-code
Error: Process completed with exit code 2.
#+end_src

It’s nice that it catches it and points me to where.

** I can use Valgrind to check this

#+begin_src
valgrind --leak-check=full ./git-format-patch     --no-to     --no-cc     --to=kristofferhaugsbakk@fastmail.com     --cover-letter     --output-directory=patches     --header-cmd=./test-cmd     --add-header='X-Not-Command-Header: not that'     'HEAD^{/★meta}'..@
#+end_src

Gives something like this:

#+begin_src
==260736== 12,313 bytes in 1 blocks are definitely lost in loss record 166 of 179
==260736==    at 0x484DCD3: realloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==260736==    by 0x45C4D4: xrealloc (wrapper.c:137)
==260736==    by 0x4102FC: strbuf_grow (strbuf.c:101)
==260736==    by 0x411AFC: strbuf_read_once (strbuf.c:519)
==260736==    by 0x3E5478: pump_io_round (run-command.c:1361)
==260736==    by 0x3E554E: pump_io (run-command.c:1384)
==260736==    by 0x3E5933: pipe_command (run-command.c:1448)
==260736==    by 0x1A5555: capture_command (run-command.h:252)
==260736==    by 0x1AAF43: set_header_cmd_output (log.c:1898)
==260736==    by 0x1ACFC7: cmd_format_patch (log.c:2371)
==260736==    by 0x129B42: run_builtin (git.c:469)
==260736==    by 0x129FCA: handle_builtin (git.c:724)
#+end_src
