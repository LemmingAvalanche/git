* Troubleshooting segv still
[2024-02-07 on.]

This also fails:

#+begin_src
./git-format-patch --no-cover-letter --header-cmd=./test-cmd 'HEAD^{/★meta: base}'..@
#+end_src

=--no-cover-letter=

I was wondering if the cover letter was the culprit…? Anyway. It looks
like I get to process all my patches. Because it prints the patch name
of the last commit (currently) before dying:

#+begin_src
0038-NOTE-Smooth.patch
#+end_src

So does it die when cleaning up?

* Testing on my own email (21:39)
[2024-02-07 on.]

Sent it to my own email and the command-headers survive transit.

* Uuuh... extra headers are not generated for the cover letter?

Try for yourself:

#+begin_src
./git-format-patch --output-directory=patches --add-header='X-Complete-Garbage: ææææææææææææææ' --header-cmd=./test-cmd 'HEAD^{/★meta: base}'..@
#+end_src

This is the cover letter:

#+begin_src
From 9a8350fbc2e2ccbe63521a0faebab26bd8779738 Mon Sep 17 00:00:00 2001
Message-ID: <cover.1707418202.git.code@khaugsbakk.name>
From: Kristoffer Haugsbakk <code@khaugsbakk.name>
Date: Thu, 8 Feb 2024 19:50:02 +0100
Subject: [PATCH 00/40] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***
[…]
#+end_src

** Update: gulp, this must be a bug on my branch

Because I can’t reproduce it on master.

** TODO Fix =--add-header= for cover letter regression

...

I’m pretty sure it’s my move of

#+begin_src
rev.extra_headers = to_free = strbuf_detach(&buf, NULL);
#+end_src

But for fucks sake! The code is so fucking obtuse. Now I have to
restructure everything? God /fucking/ damnit.

** But there might be another way…

I have a /string buffer/. Right? I could, for each patch

- Push the extra headers on the buffer
- Pop after

The problem though is that the stupid =rev.extra_headers= is just a dumb
fucking char pointer. Ugh.

* TODO on commit “Never say die” ca.: CI fails because of leak

https://github.com/LemmingAvalanche/git/actions/runs/7905330519/job/21577718875

#+begin_src
Direct leak of 24 byte(s) in 1 object(s) allocated from:
    #0 0x7f52806124a3 in __interceptor_realloc ../../../../src/libsanitizer/lsan/lsan_interceptors.cpp:98
    #1 0x55c2158756b5 in xrealloc wrapper.c:137
    #2 0x55c215829412 in strbuf_grow strbuf.c:101
    #3 0x55c21573197e in all_headers log-tree.c:475
    #4 0x55c215731a2d in log_write_email_headers log-tree.c:490
    #5 0x55c21573297c in show_log log-tree.c:755
    #6 0x55c21573403c in log_tree_commit log-tree.c:1176
    #7 0x55c2155bf7db in cmd_log_walk_no_free builtin/log.c:522
    #8 0x55c2155c08b8 in cmd_show builtin/log.c:821
    #9 0x55c215542b42 in run_builtin git.c:469
    #10 0x55c215542fca in handle_builtin git.c:724
    #11 0x55c215543271 in run_argv git.c:788
    #12 0x55c21554385c in cmd_main git.c:923
    #13 0x55c21565827f in main common-main.c:62
    #14 0x7f5280229d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #15 0x7f5280229e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #16 0x55c215540cc4 in _start (git+0x1fcc4) (BuildId: 8c1bff2742603d7b82440c84a644906d8bf3435c)

DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--show_log--log_tree_commit--cmd_log_walk_no_free--cmd_show--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).
As TEST_PASSES_SANITIZE_LEAK=true and our logs show we're leaking, exit non-zero!
# faking up non-zero exit with --invert-exit-code
Error: Process completed with exit code 2.
#+end_src

It’s nice that it catches it and points me to where.

** I can use Valgrind to check this

#+begin_src shell
valgrind --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
    ./git-format-patch    --no-to     --no-cc     --to=kristofferhaugsbakk@fastmail.com     --cover-letter     --output-directory=patches     --header-cmd=./test-cmd     --add-header='X-Not-Command-Header: not that'     'HEAD^{/★meta}'..@
#+end_src

*** TODO And read up on all of this complicated junk ... https://stackoverflow.com/a/44989219/1725151

Gives something like this:

#+begin_src
==260736== 12,313 bytes in 1 blocks are definitely lost in loss record 166 of 179
==260736==    at 0x484DCD3: realloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==260736==    by 0x45C4D4: xrealloc (wrapper.c:137)
==260736==    by 0x4102FC: strbuf_grow (strbuf.c:101)
==260736==    by 0x411AFC: strbuf_read_once (strbuf.c:519)
==260736==    by 0x3E5478: pump_io_round (run-command.c:1361)
==260736==    by 0x3E554E: pump_io (run-command.c:1384)
==260736==    by 0x3E5933: pipe_command (run-command.c:1448)
==260736==    by 0x1A5555: capture_command (run-command.h:252)
==260736==    by 0x1AAF43: set_header_cmd_output (log.c:1898)
==260736==    by 0x1ACFC7: cmd_format_patch (log.c:2371)
==260736==    by 0x129B42: run_builtin (git.c:469)
==260736==    by 0x129FCA: handle_builtin (git.c:724)
#+end_src

** Freshest output for this command

(There’s a lot of output that is not about my codepath it seems)

Looks relevant

#+begin_src
==72229== 384 bytes in 1 blocks are still reachable in loss record 77 of 103
==72229==    at 0x48487A9: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==72229==    by 0x45C4F6: xrealloc (wrapper.c:137)
==72229==    by 0x4150C7: string_list_append_nodup (string-list.c:218)
==72229==    by 0x415155: string_list_append (string-list.c:228)
==72229==    by 0x1A7CD3: add_header (log.c:928)
==72229==    by 0x1A9D5D: header_callback (log.c:1584)
==72229==    by 0x37C401: do_get_value (parse-options.c:164)
==72229==    by 0x37C87E: get_value (parse-options.c:257)
==72229==    by 0x37CF7C: parse_long_opt (parse-options.c:426)
==72229==    by 0x37E912: parse_options_step (parse-options.c:950)
==72229==    by 0x37EC24: parse_options (parse-options.c:1018)
==72229==    by 0x1AC04D: cmd_format_patch (log.c:2083)
#+end_src

** Valgrind mentioned in =t/README=

Note =--leak-check=no=

#+begin_src
--valgrind=<tool>::
	Execute all Git binaries under valgrind tool <tool> and exit
	with status 126 on errors (just like regular tests, this will
	only stop the test script when running under -i).

	Since it makes no sense to run the tests with --valgrind and
	not see any output, this option implies --verbose.  For
	convenience, it also implies --tee.

	<tool> defaults to 'memcheck', just like valgrind itself.
	Other particularly useful choices include 'helgrind' and
	'drd', but you may use any tool recognized by your valgrind
	installation.

	As a special case, <tool> can be 'memcheck-fast', which uses
	memcheck but disables --track-origins.  Use this if you are
	running tests in bulk, to see if there are _any_ memory
	issues.

	Note that memcheck is run with the option --leak-check=no,
	as the git process is short-lived and some errors are not
	interesting. In order to run a single command under the same
	conditions manually, you should set GIT_VALGRIND to point to
	the 't/valgrind/' directory and use the commands under
	't/valgrind/bin/'.
#+end_src

* Backup of =config.mak=

Because this isn’t version controlled yet… :)

#+begin_src
DEVELOPER=1
DEBUG=1
CFLAGS+=-O0
CFLAGS+=-ggdb3
#+end_src

* CI fails again on d8c6748e83 (I think I need to free here, 2024-02-16)

https://github.com/LemmingAvalanche/git/actions/runs/7935265291/job/21668024101

#+begin_src
ok 12 - --start-number && --numbered
+ git format-patch --cover-letter --stdout HEAD~1
Aborted (core dumped)
error: last command exited with $?=134
not ok 13 - single patch with cover-letter defaults to numbers
#
#		git format-patch --cover-letter --stdout HEAD~1 >patch9.single &&
#		test_single_cover_letter_numbered patch9.single
#

+ git format-patch --no-numbered --stdout --cover-letter HEAD~1
Aborted (core dumped)
error: last command exited with $?=134
not ok 14 - Use --no-numbered and --cover-letter single patch
#
#		git format-patch --no-numbered --stdout --cover-letter HEAD~1 >patch10 &&
#		test_no_numbered patch10
#

+ rmdir /home/runner/work/git/git/t/test-results/t4021-format-patch-numbered.leak
+ :
+ exit 134
+ eval_ret=134
+ :
# failed 2 among 14 test(s)
1..14
With SANITIZE=leak at exit we have 2 leak logs, but started with 0

This means that we have a blindspot where git is leaking but we're
losing the exit code somewhere, or not propagating it appropriately
upwards!

See the logs at "/home/runner/work/git/git/t/test-results/t4021-format-patch-numbered.leak/trace.*";
those logs are reproduced below.

=================================================================
==git==124764==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 24 byte(s) in 1 object(s) allocated from:
    #0 0x7fa9c9a124a3 in __interceptor_realloc ../../../../src/libsanitizer/lsan/lsan_interceptors.cpp:98
    #1 0x56344abfe6ff in xrealloc wrapper.c:137
    #2 0x56344abb245c in strbuf_grow strbuf.c:101
    #3 0x56344aaba9a0 in all_headers log-tree.c:475
    #4 0x56344aabaa4f in log_write_email_headers log-tree.c:490
    #5 0x56344a94b355 in make_cover_letter builtin/log.c:1356
    #6 0x56344a94f0f5 in cmd_format_patch builtin/log.c:2375
    #7 0x56344a8cbb42 in run_builtin git.c:469
    #8 0x56344a8cbfca in handle_builtin git.c:724
    #9 0x56344a8cc271 in run_argv git.c:788
    #10 0x56344a8cc85c in cmd_main git.c:923
    #11 0x56344a9e12a1 in main common-main.c:62
    #12 0x7fa9c9629d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #13 0x7fa9c9629e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #14 0x56344a8c9cc4 in _start (git+0x1fcc4) (BuildId: c075050a9ee7fa65d1e9dcdffb88185d2bda3840)

DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--make_cover_letter--cmd_format_patch--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).

=================================================================
==git==125072==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 24 byte(s) in 1 object(s) allocated from:
    #0 0x7fe65dc124a3 in __interceptor_realloc ../../../../src/libsanitizer/lsan/lsan_interceptors.cpp:98
    #1 0x55d2ca14c6ff in xrealloc wrapper.c:137
    #2 0x55d2ca10045c in strbuf_grow strbuf.c:101
    #3 0x55d2ca0089a0 in all_headers log-tree.c:475
    #4 0x55d2ca008a4f in log_write_email_headers log-tree.c:490
    #5 0x55d2c9e99355 in make_cover_letter builtin/log.c:1356
    #6 0x55d2c9e9d0f5 in cmd_format_patch builtin/log.c:2375
    #7 0x55d2c9e19b42 in run_builtin git.c:469
    #8 0x55d2c9e19fca in handle_builtin git.c:724
    #9 0x55d2c9e1a271 in run_argv git.c:788
    #10 0x55d2c9e1a85c in cmd_main git.c:923
    #11 0x55d2c9f2f2a1 in main common-main.c:62
    #12 0x7fe65d829d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #13 0x7fe65d829e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #14 0x55d2c9e17cc4 in _start (git+0x1fcc4) (BuildId: c075050a9ee7fa65d1e9dcdffb88185d2bda3840)

DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--make_cover_letter--cmd_format_patch--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).
As TEST_PASSES_SANITIZE_LEAK=true and our logs show we're leaking, and we're failing for other reasons too...
------------------------------------------------------------------------
test-results/t4052-stat-output.out...
------------------------------------------------------------------------
#+end_src

* Latest failed CI

https://github.com/LemmingAvalanche/git/actions/runs/7935738898/job/21669533627

* Using a free list of something

I could try to make a free list of all strbuf that I have allocated for
the command output of header_cmd.

There is apparently this function:

#+begin_src
strbuf_list_free
#+end_src

So I could use that.

It seems that it is just a free list specifically for strbuf.

** Update: doesn’t seem appropriate

All the usages I’ve found get this double pointer from some strbuf
function. Hmm, which is not the case for me.

How about using =string_list=?

* We’re still leaking in “Don’t take ownership here, either”

https://github.com/LemmingAvalanche/git/actions/runs/7941079667/job/21683041041

#+begin_src
DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--show_log--log_tree_commit--cmd_log_walk_no_free--cmd_show--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).

=================================================================
==git==160141==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 24 byte(s) in 1 object(s) allocated from:
    #0 0x7ff2ec4124a3 in __interceptor_realloc ../../../../src/libsanitizer/lsan/lsan_interceptors.cpp:98
    #1 0x5643e77c9762 in xrealloc wrapper.c:137
    #2 0x5643e777d4bf in strbuf_grow strbuf.c:101
    #3 0x5643e7685a0e in all_headers log-tree.c:475
    #4 0x5643e7685ab0 in log_write_email_headers log-tree.c:491
    #5 0x5643e7686a0c in show_log log-tree.c:756
    #6 0x5643e76880cc in log_tree_commit log-tree.c:1177
    #7 0x5643e75137fb in cmd_log_walk_no_free builtin/log.c:522
    #8 0x5643e75148d8 in cmd_show builtin/log.c:821
    #9 0x5643e7496b42 in run_builtin git.c:469
    #10 0x5643e7496fca in handle_builtin git.c:724
    #11 0x5643e7497271 in run_argv git.c:788
    #12 0x5643e749785c in cmd_main git.c:923
    #13 0x5643e75ac309 in main common-main.c:62
    #14 0x7ff2ec029d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #15 0x7ff2ec029e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #16 0x5643e7494cc4 in _start (git+0x1fcc4) (BuildId: b0f24bfac3c0aca8690f7812fee2ae65a6ad674c)

DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--show_log--log_tree_commit--cmd_log_walk_no_free--cmd_show--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).
As TEST_PASSES_SANITIZE_LEAK=true and our logs show we're leaking, exit non-zero!
# faking up non-zero exit with --invert-exit-code
Error: Process completed with exit code 2.
#+end_src

* Still leaking in “Revert "Take ownership of pointer (extra_headers)"”

https://github.com/LemmingAvalanche/git/actions/runs/7941325609/job/21683554019

#+begin_src
DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--show_log--log_tree_commit--cmd_log_walk_no_free--cmd_show--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).

=================================================================
==git==160230==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 24 byte(s) in 1 object(s) allocated from:
    #0 0x7f65c80124a3 in __interceptor_realloc ../../../../src/libsanitizer/lsan/lsan_interceptors.cpp:98
    #1 0x564a6e8f0755 in xrealloc wrapper.c:137
    #2 0x564a6e8a44b2 in strbuf_grow strbuf.c:101
    #3 0x564a6e7aca0e in all_headers log-tree.c:475
    #4 0x564a6e7acab0 in log_write_email_headers log-tree.c:491
    #5 0x564a6e7ad9ff in show_log log-tree.c:756
    #6 0x564a6e7af0bf in log_tree_commit log-tree.c:1177
    #7 0x564a6e63a7fb in cmd_log_walk_no_free builtin/log.c:522
    #8 0x564a6e63b8d8 in cmd_show builtin/log.c:821
    #9 0x564a6e5bdb42 in run_builtin git.c:469
    #10 0x564a6e5bdfca in handle_builtin git.c:724
    #11 0x564a6e5be271 in run_argv git.c:788
    #12 0x564a6e5be85c in cmd_main git.c:923
    #13 0x564a6e6d3309 in main common-main.c:62
    #14 0x7f65c7c29d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #15 0x7f65c7c29e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #16 0x564a6e5bbcc4 in _start (git+0x1fcc4) (BuildId: 3cad906c4158add6c8e9c9ffcb88272ce0c011d9)

DEDUP_TOKEN: __interceptor_realloc--xrealloc--strbuf_grow--all_headers--log_write_email_headers--show_log--log_tree_commit--cmd_log_walk_no_free--cmd_show--run_builtin--handle_builtin--run_argv--cmd_main--main----__libc_start_main--_start
SUMMARY: LeakSanitizer: 24 byte(s) leaked in 1 allocation(s).
As TEST_PASSES_SANITIZE_LEAK=true and our logs show we're leaking, exit non-zero!
# faking up non-zero exit with --invert-exit-code
Error: Process completed with exit code 2.
#+end_src

* And it still leaks in

https://github.com/LemmingAvalanche/git/actions/runs/7941426522/job/21683767496

#+begin_src
Error: failed: t9001.199 --compose handles to headers
failure: t9001.199 --compose handles to headers
  	write_script fake-editor <<-\EOF &&
  	sed "s/^To: .*/&, edited-to@example.com/" <"$1" >"$1.tmp" &&
  	echo this is the body >>"$1.tmp" &&
  	mv "$1.tmp" "$1"
  	EOF
  	clean_fake_sendmail &&
  	GIT_SEND_EMAIL_NOTTY=1 \
  	git send-email \
  		--compose \
  		--from="Example <from@example.com>" \
  		--to=nobody@example.com \
  		--smtp-server="$(pwd)/fake.sendmail" \
  		HEAD^ &&
  	# Check both that the cover letter used our modified "to" line,
  	# but also that it was picked up for the patch.
  	q_to_tab >expect <<-\EOF &&
  	To: nobody@example.com,
  	Qedited-to@example.com
  	EOF
  	grep -A1 "^To:" msgtxt1 >msgtxt1.to &&
  	test_cmp expect msgtxt1.to &&
  	grep -A1 "^To:" msgtxt2 >msgtxt2.to &&
  	test_cmp expect msgtxt2.to

  + write_script fake-editor
  + echo #!/bin/sh
  + cat
  + chmod +x fake-editor
  + clean_fake_sendmail
  + rm -f commandline* msgtxt*
  + pwd
  + GIT_SEND_EMAIL_NOTTY=1 git send-email --compose --from=Example <from@example.com> --to=nobody@example.com --smtp-server=/home/runner/work/git/git/t/trash directory.t9001-send-email/fake.sendmail HEAD^
  BUG?: got SIGABRT ($? = 134, $? & 127 = 6) when closing pipe at /home/runner/work/git/git/perl/build/lib/Git.pm line 1711.
  error: last command exited with $?=255
  not ok 199 - --compose handles to headers
  #
  #		write_script fake-editor <<-\EOF &&
  #		sed "s/^To: .*/&, edited-to@example.com/" <"$1" >"$1.tmp" &&
  #		echo this is the body >>"$1.tmp" &&
  #		mv "$1.tmp" "$1"
  #		EOF
  #		clean_fake_sendmail &&
  #		GIT_SEND_EMAIL_NOTTY=1 \
  #		git send-email \
  #			--compose \
  #			--from="Example <from@example.com>" \
  #			--to=nobody@example.com \
  #			--smtp-server="$(pwd)/fake.sendmail" \
  #			HEAD^ &&
  #		# Check both that the cover letter used our modified "to" line,
  #		# but also that it was picked up for the patch.
  #		q_to_tab >expect <<-\EOF &&
  #		To: nobody@example.com,
  #		Qedited-to@example.com
  #		EOF
  #		grep -A1 "^To:" msgtxt1 >msgtxt1.to &&
  #		test_cmp expect msgtxt1.to &&
  #		grep -A1 "^To:" msgtxt2 >msgtxt2.to &&
  #		test_cmp expect msgtxt2.to
  #
Error: Process completed with exit code 1.
#+end_src

That =BUG= is from

#+begin_src
		} elsif ($? & 127 && _is_sig($? & 127, "SIGABRT")) {
			die sprintf('BUG?: got SIGABRT ($? = %d, $? & 127 = %d) when closing pipe',
				    $?, $? & 127);
#+end_src

Some perl stuffz.

How on earth could this be related to my thing?

* No leaks on the base commit

I have based this branch for now on =v2.44.0-rc1=. And… No leaks from
running CI on that.

https://github.com/LemmingAvalanche/git/actions/runs/7942187391

* Test failue on “Back to owning the pointers”

#+begin_src
./t4014-format-patch.sh --verbose-only=25
#+end_src

Run the command manually. The header/message separation is messed up:

#+begin_src
From ae7a71142149d1c89c15bc659034fce5ec05f616 Mon Sep 17 00:00:00 2001
Message-ID: <ae7a71142149d1c89c15bc659034fce5ec05f616.1708105356.git.code@khaugsbakk.name>
In-Reply-To: <cover.1708105355.git.code@khaugsbakk.name>
References: <cover.1708105355.git.code@khaugsbakk.name>
From: Kristoffer Haugsbakk <code@khaugsbakk.name>
Date: Wed, 7 Feb 2024 20:50:41 +0100
Subject: [PATCH 02/44] NOTE Fucking pray to god now
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Not-Command-Header: not that
To: kristofferhaugsbakk@fastmail.com
X-Version: 1
X-ShaOne: ae7a71142149d1c89c15bc659034fce5ec05f616
X-Count: 2
X-Patch-Type: commit
NOTE BUT GUESS FUCKING WHAT

    ```
    patches/0033-Fucking-pray-to-god-now.patch
    Segmentation fault (core dumped)
    ```

    Well it’s not that bad. We are able to print all the patches.

    It just fails after that. During cleanup?
---
#+end_src

* How to validate header-cmd output

=--header-cmd= for send-email does some validation. I guess I should do
some too.

** Minimal

Check that there are no blank lines.

** Research on existing code

- am.c
  - Has =is_mail= which looks promising
- mailinfo.c
  - =is_rfc2822_header=

* TODO Umm... my header check doesn’t seem to work

This doesn’t error. It should error.

#+begin_src
./git-format-patch     --no-cc     --description-file=cover-letter.txt     --to=kristofferhaugsbakk@fastmail.com     --cover-letter     --output-directory=patches     --header-cmd=./test-cmd-corrupted     --add-header='X-Not-Command-Header: not that'     'HEAD^{/★meta}'..@
#+end_src
